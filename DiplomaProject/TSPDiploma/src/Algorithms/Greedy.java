package Algorithms;

import java.util.*;


public class Greedy {
  private final int MAX_NODES = 50;
  private HashSet nodes[];               // Array of connected components
  private TreeSet allEdges;              // Priority queue of Edge objects
  private Vector allNewEdges;            // Edges in Minimal-Spanning Tree
  int vertexCount;


  public Greedy() {
    // Constructor
    nodes = new HashSet[MAX_NODES];      // Create array for components
    allEdges = new TreeSet(new Edge());  // Create empty priority queue
    allNewEdges = new Vector(MAX_NODES); // Create vector for MST edges
  }

  public void readInGraphData(float[][]matrix)
  {
      vertexCount = matrix.length;
      
      for (int y=0;y<matrix.length;y++)
      {
          for (int x=0;x<matrix[y].length;x++)
          {
            int from = x;
            int to   = y;
            int cost = (int)(1000*matrix[x][y]);
            allEdges.add(new Edge(from, to, cost));  // Update priority queue
            if (nodes[from] == null) {
              // Create set of connect components [singleton] for this node
              nodes[from] = new HashSet(2*MAX_NODES);
              nodes[from].add(new Integer(from));
            }

            if (nodes[to] == null) {
              // Create set of connect components [singleton] for this node
              nodes[to] = new HashSet(2*MAX_NODES);
              nodes[to].add(new Integer(to));
            }
          }   
      }
  }

  public void GreedySearch() {
    int size = allEdges.size();
    for (int i=0; i<size; i++) {
      Edge curEdge = (Edge) allEdges.first();
      if (allEdges.remove(curEdge)) {
        // successful removal from priority queue: allEdges

        if (nodesAreInDifferentSets(curEdge.from, curEdge.to)/*||allNewEdges.size()!= vertexCount -2) */&& noThirdDegree(curEdge.from, curEdge.to)) {
          // System.out.println("Nodes are in different sets ...");
          HashSet src, dst;
          int dstHashSetIndex;

          if (nodes[curEdge.from].size() > nodes[curEdge.to].size()) {
            // have to transfer all nodes including curEdge.to
            src = nodes[curEdge.to];
            dst = nodes[dstHashSetIndex = curEdge.from];
          } else {
            // have to transfer all nodes including curEdge.from
            src = nodes[curEdge.from];
            dst = nodes[dstHashSetIndex = curEdge.to];
          }

          Object srcArray[] = src.toArray();
          int transferSize = srcArray.length;
          for (int j=0; j<transferSize; j++) {
            // move each node from set: src into set: dst
            // and update appropriate index in array: nodes
            if (src.remove(srcArray[j])) {
              dst.add(srcArray[j]);
              nodes[((Integer) srcArray[j]).intValue()] = nodes[dstHashSetIndex];
            } else {
              // This is a serious problem
              System.out.println("Something wrong: set union");
              System.exit(1);
            }
          }
          allNewEdges.add(curEdge);
          // add new edge to MST edge vector
        } else {
          // System.out.println("Nodes are in the same set ... nothing to do here");
        }

      } else {
        // This is a serious problem
        System.out.println("TreeSet should have contained this element!!");
        System.exit(1);
      }
    }
  }

  private boolean nodesAreInDifferentSets(int a, int b) {
    // returns true if graph nodes (a,b) are in different
    // connected components, ie the set for 'a' is different
    // from that for 'b'
    return(!nodes[a].equals(nodes[b]));
  }

  private void printFinalEdges() {
    System.out.println("The minimal spanning tree generated by "+
      "\nKruskal's algorithm is: ");
    while (!allNewEdges.isEmpty()) {
      // for each edge in Vector of MST edges
      Edge e = (Edge) allNewEdges.firstElement();
      System.out.println("Nodes: (" + e.from + ", " + e.to +
        ") with cost: " + e.cost);
      allNewEdges.remove(e);
    }
  }
  
  public int [][] getResultAdjacencyMatrix ()
  {
   int [][] edges = new int[vertexCount][vertexCount];
   for (Object e : allNewEdges)
   {
       Edge edge = (Edge)e;
       edges [edge.from][edge.to] = 1;
   }
   return edges;
  }
  
 /* public int[] getSolutionVertices()
  {
     int i=0;
     int [] solution = new int [vertexCount];
     for (Object e : allNewEdges)
    {
        Edge edge = (Edge)e;
        solution [i++] = edge.from;
    }       
     return solution;
  }*/
  
  public int[] getSolutionVertices()
  {
      int [] solution;
      int [][]adj = getResultAdjacencyMatrix();
        for (int y=0;y<adj.length;y++)
        {
            for (int x=0;x<adj[y].length;x++)
            {
                if (adj[x][y] == 1 || adj[y][x] ==1)
                {
                    adj[x][y] = 1;
                    adj[y][x] = 1;
                }    
            }
        }
        solution = new int [adj.length+1];
        int idx = 0;
        DFS.DFS(adj, new boolean[adj.length], solution, adj.length, 0, idx);
        return solution;
  }
   /* public int[] getSolutionVertices() {
        /*int[] solution = null;
        Object[] edges = allNewEdges.toArray();
        Arrays.sort(edges, new Comparator<Object>() {
            @Override
            public int compare(Object o1, Object o2) {
                Edge e1 = (Edge) o1;
                Edge e2 = (Edge) o2;
                if (e1.from < e2.from) {
                    return -1;
                }
                if (e1.from == e2.from) {
                    return 0;
                }
                return 1;
            }
        });
        solution = new int[edges.length];
        int [] orderedEdges = new int[vertexCount];
        */
        //int k=0;
        /*
        for (int i = 0; i < edges.length; i++) 
        {
             Edge edgei = (Edge)edges[i];
             int from = edgei.from;
             int to = edgei.to;
             orderedEdges[k++]=from;
             orderedEdges[k++]=to;
            
            for (int j = i + 1; j < edges.length; j++) 
            {
               Edge edgej = (Edge)edges[i];
               
             }
        }*/
        
      //  Edge edge0 = (Edge)edges[0];
        // int from = edge0.from;
        // int to = edge0.to;
      //   orderedEdges[k++]=from;
       //  orderedEdges[k++]=to;
        // edge0.from = -1;
         //edge0.to = -1;
        /*
        for (int x = 0 ; x<edges.length;x++)
        {
             Edge edgex = (Edge)edges[x];
             int from = edgex.from;
             int to = edgex.to;
             //orderedEdges[k++]=from;
             //orderedEdges[k++]=to;
             edgex.from = -1;
             edgex.to = -1;
            
            for (int y=0;y<edges.length;y++)
            {
                Edge edgey = (Edge)edges[y];
                if (edgey.from == to)
                {
                
                }
            }
        
        }
        for (int i = 0; i < solution.length; i++) 
        {
            Edge edgei = (Edge) edges[i];
            solution[i] = edgei.from;
        }
        return solution;*/
   // }

  //return true if there is no second degree from / to vertex in allNewEdges
    private boolean noThirdDegree(int from, int to)
    {
        int fromCount =0, toCount=0;
        
        for (Object o: allNewEdges)
        {
            Edge e = (Edge)o;
            if (e.from == from)
                fromCount++;
            else if (e.to == to)
                toCount++;
            if(e.to == to)
                toCount++;
            else if (e.to == from)
                fromCount++;
        }
        return (fromCount<2 && toCount <2);
    }
    

  class Edge implements Comparator {
    // Inner class for representing edge+end-points
    public int from, to, cost;
    public Edge() {
      // Default constructor for TreeSet creation
    }
    public Edge(int f, int t, int c) {
      // Inner class constructor
      from = f; to = t; cost = c;
    }
    public int compare(Object o1, Object o2) {
      // Used for comparisions during add/remove operations
      int cost1 = ((Edge) o1).cost;
      int cost2 = ((Edge) o2).cost;
      int from1 = ((Edge) o1).from;
      int from2 = ((Edge) o2).from;
      int to1   = ((Edge) o1).to;
      int to2   = ((Edge) o2).to;

      if (cost1<cost2)
        return(-1);
      else if (cost1==cost2 && from1==from2 && to1==to2)
        return(0);
      else if (cost1==cost2)
        return(-1);
      else if (cost1>cost2)
        return(1); 
      else
        return(0);
    }
    public boolean equals(Object obj) {
      // Used for comparisions during add/remove operations
      Edge e = (Edge) obj;
      return (cost==e.cost && from==e.from && to==e.to);
    }
  }
  
}